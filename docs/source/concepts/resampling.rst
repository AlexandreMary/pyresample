Resampling
==========

In the general sense, resampling is the process of creating new data points
from data we already have. In Pyresample, we use the term "resample" when we
transform data from one :doc:`geometry <geometries>` to another. With
the available geometries in mind we typically use resampling in a few common
use cases:

* swath to area: Or in another way, resampling ungridded data to a grid.
  This is useful for many reasons. Most areas are easy to visualize and
  provide a view of the Earth that is somewhat recognizable. This isn't
  always true of swaths. This resampling has all the other benefits of
  areas too such as being easier to describe the geolocation and easier
  to compare with other data. This type of resampling also allows getting
  a subset of the swath or changing the spatial pixel resolution to something
  more suited for your use case.
* area/swath to swath: When combining or comparing data from multiple sources
  and both of them happen to be ungridded swaths, resampling can be used
  to bring them on to the same coordinate system.
* area to area: Similar to resampling a swath to an area, we may want to get
  a subset of the input data or change the resolution so that it suits
  our needs. There is also the opportunity to change projections or to match
  the area for another dataset for easier comparison.

In all of these cases we need some way to determine what value to set for
each output pixel given one or more input pixels. For this there are many
algorithms to choose from. The algorithms implemented in Pyresample are
described below.

For more information on how to do resampling with
Pyresample see some of the :doc:`/howtos/index` such as :doc:`/howtos/swath`
for swath data or :doc:`/howtos/grid` for areas.

Algorithms
----------

When resampling we have a lot of options for mapping input pixels to an output
pixel. Depending on the algorithm we choose we may get better looking results
than others, but at the cost of more processing time or larger memory
requirements. Below is a basic description of some of the algorithms
implemented in Pyresample, but for a more detailed description see the
:doc:`API documentation </api/pyresample>` where the low-level resampler classes
and functions are documented.

Note that unless otherwise stated, the algorithms implemented in Pyresample
consider all pixels as individual points located at their centers. This means
they may generally ignore the shape of the real world footprint and possible
overlap of these footprints.

.. warning::

   Pyresample's resampling interfaces are currently undergoing changes as part
   of the version 2.0 redesign. As such, the existing algorithms described
   below may only be available from specific interfaces and may or may not be
   consistent with the interfaces of other algorithms. Some algorithms, at the
   time of writing, may only support data types needed to work with
   Pyresample's sibling project "Satpy". For example, some may expect Xarray
   ``DataArray`` classes with dask arrays underneath and will fail in ugly ways
   if given regular numpy arrays.

Nearest Neighbor
^^^^^^^^^^^^^^^^

Nearest neighbor is one of the simplest resampling algorithms available. It
sets every output pixel to the value of the input pixel that is geographically
closest to the output pixel's location. In Pyresample this is implemented using
a `k-d tree <https://en.wikipedia.org/wiki/K-d_tree>`_ via the
`pykdtree package <https://github.com/storpipfugl/pykdtree>`_. This structure
is created using the input geolocation and allows for quick querying for the
index of the nearest input pixel. Using these indexes we can create an output
array the size of the target geometry using a basic numpy indexing operation.
This is normally a very fast operation.

Any pixel in the output array that doesn't have a neighboring input pixel will
be assigned some fill value, typically the special floating point NaN. The
algorithm decides how far to look by a "radius of influence". Regardless of
the radius of influence, the result will always be the nearest neighboring
pixel if there is one within the radius, otherwise the fill value will be
used.

One good part about this algorithm and its simplicity is that it works with
any pair of input and output geometries (swath, area, etc). This is not
necessarily true for all algorithms.
This is the oldest algorithm implemented in pyresample and has been adapted in
different interfaces to support numpy, dask, and xarray DataArrays.

Caching
*******

Due to the way this algorithm uses the k-d tree and the indexes generated by
querying it, the indexes can be easily cached. Since the kd-tree only uses
input geolocation for creation and output geolocation for querying, we can
reuse the generated indexes for any input data sharing the same geolocation.
This can increase performance greatly by not having to regenerate or requery
the k-d tree. If our swath or area-based input is the same between executions
we can also write these indexes to disk and use them in the next execution
without having to generate or query a k-d tree.

Gradient Search
^^^^^^^^^^^^^^^

:doi:`10.1109/TGRS.2008.916633`

.. warning::

   This resampling algorithm is still considered experimental.

Bilinear
^^^^^^^^

Bucket
^^^^^^

Elliptical Weighted Averaging
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
